/// API for a Facility test server.
[csharp(namespace: Facility.ConformanceApi)]
service ConformanceApi
{
	/// Gets API information.
	[http(method: get, path: "/")]
	method getApiInfo
	{
	}:
	{
		/// The name of the service.
		service: string;

		/// The version of the service.
		version: string;
	}

	/// Creates a new widget.
	[http(method: POST, path: "/widgets")]
	[tag(name: widgets)]
	method createWidget
	{
		/// The widget to create.
		[http(from: body)]
		widget: Widget;
	}:
	{
		/// The created widget.
		[http(from: body, code: 201)]
		widget: Widget;

		/// The URL of the created widget.
		[http(from: header, name: Location)]
		url: string;

		/// The ETag of the created widget.
		[http(from: header)]
		eTag: string;
	}

	/// Gets the specified widget.
	[http(method: GET, path: "/widgets/{id}")]
	[tag(name: widgets)]
	method getWidget
	{
		/// The widget ID.
		id: int32;

		/// Don't get the widget if it has this ETag.
		[http(from: header, name: If-None-Match)]
		ifNotETag: string;
	}:
	{
		/// The requested widget.
		[http(from: body)]
		widget: Widget;

		/// The ETag of the widget.
		[http(from: header)]
		eTag: string;

		/// The widget still has the specified ETag.
		[http(from: body, code: 304)]
		notModified: boolean;
	}

	/// Deletes the specified widget.
	[http(method: DELETE, path: "/widgets/{id}", code: 204)]
	[tag(name: widgets)]
	method deleteWidget
	{
		/// The widget ID.
		id: int32;

		/// Don't delete the widget unless it has this ETag.
		[http(from: header, name: If-Match)]
		ifETag: string;
	}:
	{
		/// The widget was not found.
		[http(from: body, code: 404)]
		notFound: boolean;

		/// The widget no longer has the specified ETag.
		[http(from: body, code: 409)]
		conflict: boolean;
	}

	/// A widget.
	[tag(name: widgets)]
	data Widget
	{
		/// A unique identifier for the widget.
		id: int32;

		/// The name of the widget.
		name: string;
	}

	method mirrorFields
	{
		field: Any;
		matrix: double[][][];
	}:
	{
		field: Any;
		matrix: double[][][];
	}

	[http(method: GET)]
	method checkQuery
	{
		string: string;
		boolean: boolean;
		double: double;
		int32: int32;
		int64: int64;
		decimal: decimal;
		enum: Answer;
	}:
	{
	}

	[http(method: GET, path: "/mirror/{string}/{boolean}/{double}/{int32}/{int64}/{decimal}/{enum}")]
	method checkPath
	{
		string: string;
		boolean: boolean;
		double: double;
		int32: int32;
		int64: int64;
		decimal: decimal;
		enum: Answer;
	}:
	{
	}

	[http(method: GET)]
	method mirrorHeaders
	{
		[http(from: header)] string: string;
		[http(from: header)] boolean: boolean;
		[http(from: header)] double: double;
		[http(from: header)] int32: int32;
		[http(from: header)] int64: int64;
		[http(from: header)] decimal: decimal;
		[http(from: header)] enum: Answer;
	}:
	{
		[http(from: header)] string: string;
		[http(from: header)] boolean: boolean;
		[http(from: header)] double: double;
		[http(from: header)] int32: int32;
		[http(from: header)] int64: int64;
		[http(from: header)] decimal: decimal;
		[http(from: header)] enum: Answer;
	}

	data Any
	{
		string: string;
		boolean: boolean;
		double: double;
		int32: int32;
		int64: int64;
		decimal: decimal;
		bytes: bytes;
		object: object;
		error: error;
		data: Any;
		enum: Answer;
		array: AnyArray;
		map: AnyMap;
		result: AnyResult;
	}

	data AnyArray
	{
		string: string[];
		boolean: boolean[];
		double: double[];
		int32: int32[];
		int64: int64[];
		decimal: decimal[];
		bytes: bytes[];
		object: object[];
		error: error[];
		data: Any[];
		enum: Answer[];
		array: int32[][];
		map: map<int32>[];
		result: result<int32>[];
	}

	data AnyMap
	{
		string: map<string>;
		boolean: map<boolean>;
		double: map<double>;
		int32: map<int32>;
		int64: map<int64>;
		decimal: map<decimal>;
		bytes: map<bytes>;
		object: map<object>;
		error: map<error>;
		data: map<Any>;
		enum: map<Answer>;
		array: map<int32[]>;
		map: map<map<int32>>;
		result: map<result<int32>>;
	}

	data AnyResult
	{
		string: result<string>;
		boolean: result<boolean>;
		double: result<double>;
		int32: result<int32>;
		int64: result<int64>;
		decimal: result<decimal>;
		bytes: result<bytes>;
		object: result<object>;
		error: result<error>;
		data: result<Any>;
		enum: result<Answer>;
		array: result<int32[]>;
		map: result<map<int32>>;
		result: result<result<int32>>;
	}

	enum Answer
	{
		yes,
		no,
		maybe,
	}
}
